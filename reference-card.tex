\documentclass[14pt]{article}

\usepackage[a4paper,left=1cm,right=1cm,top=15mm,bottom=1cm,headsep=5mm,landscape]{geometry}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{lipsum}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{tcolorbox}
\usepackage{tikz}

\definecolor{headertext}{rgb}{0.5,0.5,0.5}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
\fancyhf{}
\lhead{\color{headertext} PYTHON - REFERENZKARTE}
\chead{\color{headertext} STATISTICS FOR DATA SCIENCE}
\rhead{\color{headertext} SEITE \thepage}

\setlength{\parindent}{0cm}
\newminted[python]{python}{}
\newmintinline{python}{breaklines,tabsize=2}

\tcbset{boxrule=1pt,colback=black!4!white, title=\underline{\textbf{DataFrame für die nächsten Befehle}},colframe=black!4!white,coltitle=black}

\begin{document}
\begin{multicols*}{3}

\subsection*{Häufig verwendete Bibliotheken}
\begin{python}
import matplotlib.pyplot as plt
import scipy.stats as st
import seaborn as sns
import pandas as pd
import numpy as np
\end{python}

\subsection*{Hilfe anzeigen}
\pythoninline{help(np.random)} \\
Hilfetext eines Packages anzeigen \\

\pythoninline{help(np.random.choice)} \\
Hilfetext einer Funktion anzeigen 

\subsection*{Numpy Basics}
\pythoninline{np.e}: Konstante mit Wert von $e$ \\
\pythoninline{np.pi}:  Konstante mit Wert von $\pi$ \\
\pythoninline{np.sqrt(2)}: Wurzel von Zahl berechnen \\
\pythoninline{np.square(2)}: Quadrat von Zahl berechen \\
\pythoninline{np.abs(-45)}: Absolutwert einer Zahl berechnen \\
\pythoninline{np.round(2.35, x)}: Zahl auf \textit{x} Nachkomastellen runden \\
\pythoninline{np.log(100)}: Natürlicher Logarithmus berechnen \\
\pythoninline{np.log10(100)}: Logarithmus mit Basis 10 berechnen \\
\pythoninline{np.prod(arr)}: Produkt der Zahlen von \textit{arr}

\subsection*{Numpy Arrays}
\pythoninline{arr = np.array([2, 1, 4, 5, -8, 10])} \\
Numpy-Array erzeugen \\

\pythoninline{np.linspace(start=1, stop=2, num=4)} \\
\textit{num} Zahlen zwischen \textit{start} und \textit{stop} \\
In diesem Beispiel: [1.0, 1.333, 1.666, 2.0] \\

\pythoninline{np.arange(start=1, stop=4, step=.6)} \\
Zahlen von \textit{start} bis \textit{stop} mit inkrement \textit{step} \\
In diesem Beispiel: [1.0, 1.6, 2.2, 2.8, 3.4] \\

\pythoninline{new_arr = arr.reshape((n, m))} \\
1-dimensionales Array in 2-dimensionales umwandeln \\
Neues Array hat \textit{n} Zeilen mit je \textit{m} Elementen \\

\pythoninline{np.percentile(arr, q=[2.5, 97.5])} \\
Werte der Quantile eines Datensatz anzeigen \\
In diesem Beispiel die 2.5\%- und 97.5\%-Quantile \\

\pythoninline{np.sum(arr > x)} \\
Werte grösser als \textit{x} in einem Array zählen \\

\pythoninline{arr = np.cumsum(arr)} \\
Kumulative Summe des Array \textit{arr} berechnen\\

\pythoninline{np.nanmean(arr)} \\
Mittelwert berechnen und NaN ignorieren \\

\pythoninline{np.tile(arr, x)} \\
Array \textit{x}-Mal wiederholen und aneinander hängen \\

\pythoninline{np.repeat(["M1","M2","M3"], [x1, x2, x3])} \\
Jeder Werte des Array mit Index $i$, $x_i$-mal wiederholen \\

\pythoninline{np.corrcoef(arr_x, arr_y)} \\
Korrelationsmatrix berechnen

\subsection*{Numpy Zufallszahlen}

\pythoninline{arr = np.random.choice(arr, size=1000)} \\
Neues Array mit der Grösse \textit{size} erstellen und zufällig \\
mit Werten aus dem übergebenen Array befüllen \\

\pythoninline{arr = np.arange(1, 25)} \\
\pythoninline{np.random.choice(arr, 24, replace=False)} \\
Zahlen zufällig sortieren \\
In diesem Beispiel die Zahlen 1 bis 24 \\

\pythoninline{np.random.seed(35)} \\
Zufallszahlengenerator mit einem Wert initialisieren \\

\pythoninline{np.random.seed()} \\
Wert des Zufallszahlengenerator wieder löschen \\

\pythoninline{np.random.normal(size=1000)} \\
\textit{size} Standard-Normalverteilte Zufallszahlen generieren

\columnbreak

\subsection*{Pandas Series}
\begin{python}
series = pd.Series([79.98, 80.04, 80.02])
series = pd.Series(
  [1, 5, 9, 15, 20],
  index=("mo", "di", "mi", "do", "fr")
)
\end{python}

\pythoninline{series.sum()}: Die Summe der Elemente von \textit{series} \\
\pythoninline{series.prod()}: Das Produkt der Elemente von \textit{series} \\
\pythoninline{series.mean()}: Der Durchschnitt der Elemente von \textit{series} \\
\pythoninline{series.median()}: Der Median der Elemente von \textit{series} \\
\pythoninline{series.var()}: Die Varianz der Elemente von \textit{series} \\
\pythoninline{series.std()}: Standardabweichung von \textit{series} \\
\pythoninline{series.count()}: Anzahl Elemente der \textit{series} \\
\pythoninline{series.round(x)}: Werte auf \textit{x} Nachkomastellen runden \\
\pythoninline{series.index}: Zeilenbeschrift der Elemente von \textit{series} \\
\pythoninline{series.size}: Die Anzahl der Elemente von \textit{series} \\
\pythoninline{series[1]}: Zugriff auf ein Elemente via Index \\
\pythoninline{series["mi"]}: Zugriff via Zeilenbeschrift

\subsection*{Quantile und Quartilsdifferenz}
\pythoninline{series.quantile(q=0.25, interpolation="midpoint")}
Quantile (z.B. 25\%, 75\%, \dots) von \textit{series} berechnen \\

\pythoninline{q75, q25 = series.quantile(q = [.75, .25], }\\
\pythoninline{	interpolation="midpoint")} \\
\pythoninline{iqr = q75 - q25} \\
Quartilsdifferenz von series berechnen

\subsection*{Werte einlesen}
\pythoninline{np.loadtxt(r"./data.txt")} \\
Daten für ein Array aus einem Textfile laden \\

\pythoninline{frame = pd.read_csv(r"./data.csv", } \\
\pythoninline{	sep=",", index_col=0)} \\
Werte für eine Frame aus einem CSV auslesen \\

\pythoninline{pd.read_table(r"./gamma.txt", } \\
\pythoninline{	delim_whitespace=True)} \\
leerzeichengetrennte Daten einlesen mit Pandas

\columnbreak

\subsection*{Pandas DataFrame}
\begin{python}
frame = pd.DataFrame({
  "Luzern": ([1, 5, 9, 15, 20]),
  "Basel": ([3, 4, 12, 16, 18]),
  "Zuerich": ([8, 6, 10, 17, 23])
  }, index=["jan", "feb", "mar", "apr", "mai"]
)
\end{python}

\pythoninline{frame.columns}: Spaltenname auslesen \\ 
\pythoninline{frame.shape}: Anzahl Zeilen und Spalten des Frames \\
\pythoninline{frame.T}: Zeilen und Spalten vertauschen \\ 
\pythoninline{frame.describe()}: Kennzahlen jeder Spalte anzeigen \\
\pythoninline{frame.mean(axis=0)}: Durchschnitt pro Spalte berechnen \\ 
\pythoninline{frame.mean(axis=1)}: Durchschnitt pro Zeile berechnen \\
\pythoninline{frame.head(n)}: Erste \textit{n} Zeilen des Frames anzeigen \\
\pythoninline{frame.tail(n)}: Letzte \textit{n} Zeilen des Frames anzeigen \\
\pythoninline{frame.drop(x, 0)}: Zeile mit dem Index \textit{x} löschen \\
\pythoninline{frame.drop(x, 1)}: Spalte \textit{x} löschen \\
\pythoninline{frame.corr()}: Korrelationsmatrix berechnen

\subsection*{Umgang mit DataFrame}
\pythoninline{copy = frame.copy()} \\
Kopie eines DataFrame erstellen \\

\pythoninline{frame.loc["mar":"mai","Luzern"]} \\
Auf einen Bereiche in einem DataFrame zugreifen \\

\pythoninline{frame.loc[["mar","mai"],["Basel","Zuerich"]]} \\
Auf ausgewählt Elemente in einem DataFrame zugreifen \\

\pythoninline{frame.sort_values(by='Luzern', ascending=False)} \\
Daten im Frame nach einer Spalte sortieren \\

\pythoninline{frame.nsmallest(n, 'Luzern')} \\
\pythoninline{frame.nlargest(n, 'Luzern')} \\
Daten im Frame nach einer Spalte sortieren und dann \\ 
\textit{n} Zeilen mit grösstem oder kleinstem Werte zurückgeben \\

\pythoninline{filtered = frame[frame['Luzern'] == 0]} \\
Daten anhand des Wertes einer Spalte filtern

\columnbreak

\pythoninline{mean = frame.mean()['Luzern']} \\
\pythoninline{frame.loc[frame['Luzern'] < mean, 2:5]} \\
Daten anhand des Wertes einer Spalte filtern und die \\
Zeilen einschränken (in diesem Beispiel 2 bis 5)

\subsection*{Matplotlib PyPlot}
\pythoninline{plt.title("...")}: Titel des Plots festlegen \\
\pythoninline{plt.xlabel("...")}: X-Achsenbeschriftung festlegen \\
\pythoninline{plt.ylabel("...")}: Y-Achsenbeschriftung festlegen \\
\pythoninline{plt.show()}: Plot anzeigen \\

\pythoninline{plt.subplot(nrows=2, ncols=3, index=4)} \\
\pythoninline{plt.subplot(234)} \\
Sub-Plot mit 2 Zeilen und 3 Spalten erstellen und den \\ 
nächsten Plot an der Position 4 einfügen. Die Position wird \\
von links nach rechts und dann von oben nach unten gezählt

\subsection*{Plots erstellen}
\pythoninline{series.hist(bins=[0, 1, 10, 11, 12])} \\
Histogramm mit angegebenen Klassengrenzen plotten \\

\pythoninline{series.plot(kind="hist", edgecolor="black")} \\
Histogramm erstellen und Balken mit Farbe umrahmen \\

\pythoninline{series.plot(kind="hist", normed=True, ...)}
Normiertes Histogramm erstellen

\pythoninline{plt.hist(series.T, bins=20, density=True)} \\
Plotten eines Histograms mit der Fläche 1 \\

\pythoninline{series.plot(kind="hist", bins=20, ...)} \\
Anzahl Klassen des Histogramm manuell festlegen \\

\pythoninline{series.plot(kind='hist', cumulative=True, 
	histtype='step', normed=True)} \\
Empirische kumulative Verteilungsfunktion plotten \\

\pythoninline{series.plot(kind='box', title='Methode A')} \\
Boxplot von \textit{series} erstellen und Titel des Plots festlegen \\

\pythoninline{frame.boxplot("T", by="Time")} \\
Daten gruppieren und durch einen Boxplot anzeigen

\columnbreak

\pythoninline{frame.plot(kind='scatter', x='wine', y='mor')} \\
Streudiagramm mit zwei ausgewählten Achsen erstellen \\
Parameter \textit{x} und \textit{y} müssen auf Indizes des \textit{frame} verweisen \\

\pythoninline{b, a = np.polyfit(x_series, y_series, deg=1)} \\
\pythoninline{x = np.linspace(x_series.min(), x_series.max())} \\
\pythoninline{plt.plot(x, a + b * x, c='orange')} \\
Plotten einer Regressionsgerade, bei welcher die Daten \\
einem Polynom ersten Grades angeglichen wurden \\

\pythoninline{st.probplot(arr, plot=plt)} \\
QQ-Plot anhand einer Normalverteilung

\subsection*{Verteilungen}
\pythoninline{cdf}: Kumulative Verteilungsfunktion $P(X \leq x)$ \\
\pythoninline{ppf}: Quantile der Verteilung $\alpha_q$ \\
\pythoninline{pdf}: Dichte an der Stelle $x$ \\
\pythoninline{pmf}: Punktw'keit an der Stelle $P(X=x)$ \\
\pythoninline{rvs}: $size$ Zufallszahlen generieren \\

\pythoninline{st.poisson.pmf(mu=1.5, k=2)} \\
$P(X = 2)$ falls $X \sim Pois(1.5)$ \\

\pythoninline{st.uniform.cdf(x=1, loc=4, scale=5)} \\
$P(X \leq 1)$ falls $X \sim Unif(4, 9)$ \\
\textbf{!} \textit{scale} ist nicht Endwert, sondern Länge des Intervall \\

\pythoninline{st.uniform.pdf(x=1, loc=0, scale=7)} \\
Dichte an der Stelle \textit{x} = 1 falls $X \sim Unif(0, 7)$ \\

\pythoninline{st.uniform.rvs(size=3, loc=0, scale=7)} \\
uniform verteilte Zufallszahlen, $X_i \sim Unif(0, 7)$ \\

\pythoninline{st.expon.cdf(x=4, loc=0, scale=1/3)} \\
$P(X \leq 4)$ falls $X \sim Exp(3)$ \\
\textbf{!} \textit{scale} muss mit $1 / \lambda$ angegeben werden \\

\pythoninline{st.expon.pdf(x=1, loc=0, scale=1/3)} \\
Dichte an der Stelle \textit{x} = 1 falls $X \sim Exp(3)$ \\

\pythoninline{st.norm.cdf(x=130, loc=100, scale=15)} \\
$P(X \leq 130)$ falls $X \sim \mathcal{N}(100, 15^2)$

\columnbreak

\pythoninline{st.norm.ppf(q=0.05, loc=100, scale=15)} \\
5\% Quantile falls $X \sim \mathcal{N}(100, 15^2)$ \\

\pythoninline{st.norm.cdf(x=1.5)} \\
$P(X \leq 1.5)$ falls $X \sim \mathcal{N}(0, 1^2)$ \\

\pythoninline{st.binom.cdf(k=5100, n=10000, p=0.5)} \\
$P(X \leq 5100)$ falls $X \sim Bin(10000, 0.5)$ \\

\pythoninline{st.binom.pmf(k=1000, n=1000, p=0.5)} \\
Wert der Wahrscheinlichkeitsdichtefunktion an der Stelle $k$ \\

\pythoninline{st.t.cdf(x=168, df=149, loc=164, } \\
\pythoninline{	scale=10/np.sqrt(150))} \\
$P[\overline{X}_{150} \leq 168]$ falls $u = 164$, $\hat{o} = 10$ und $T \sim t_{149}$ \\

\pythoninline{st.t.ppf(0.05, df=v)} \\
Quantile einer T-Verteilung mit \textit{v} Freiheitsgrade \\

\pythoninline{st.norm.rvs(size=n)}\\
generiert \textit{n} normalverteilte Zahlen \\

\pythoninline{st.t.rvs(size=n, df=v)} \\
generiert \textit{n} t-verteilte Zahlen mit \textit{v} Freiheitsgrade \\

\pythoninline{st.chi2.rvs(size=n, df=v)} \\
generiert \textit{n} chi-verteilte Zahlen mit \textit{v} Freiheitsgrade

\subsection*{Integral berechnen}
\pythoninline{from scipy.integrate import quad} \\
\pythoninline{f = lambda x: x * (15 - x/4)} \\
\pythoninline{ans, _ = quad(f, 0, 60)} \\
In diesem Fall das Integral: $\int_{0}^{60} x * (15 - \frac{x}{4})$

\subsection*{Gleichung lösen}
\pythoninline{from sympy.solvers import solve} \\
\pythoninline{from sympy import Symbol} \\
\pythoninline{x = Symbol('x')} \\
\pythoninline{solve(x**2/9000 * (15/2 - x/12) - 0.9, x)} \\
Löst die Gleichung: $\frac{x^2}{9000} (\frac{15}{2} - \frac{x}{12}) - 0.9 = 0$

\columnbreak

\subsection*{Vertrauensintervall}
\pythoninline{st.t.interval(alpha=0.95, df=12, loc=80.02, } \\
\pythoninline{	scale=0.024/np.sqrt(13))} \\
95\% Vertrauensintervall einer t-Verteilung \\
wenn $n=13$, $\sigma=0.024$ und $u=80.02$ \\

\pythoninline{st.norm.interval(alpha=0.99, loc=31, } \\
\pythoninline{	scale=6/np.sqrt(10))} \\
99\% Vertrauensintervall falls $X \sim \mathcal{N}(31, 6 / \sqrt{10})$

\subsection*{Statistische Tests}
\pythoninline{st.binom_test(x=3, n=5, p=0.5)} \\
Vorzeichentest mit \textit{x} Erfolge bei \textit{n} Versuchen \\
und einer Erfolgswahrscheinlichkeit von 50\%  \\ 

\pythoninline{st.wilcoxon(arr, correction=True)} \\
Wilcoxon-Test \\

\pythoninline{st.ttest_rel(series1, series2)} \\
Statistischer Test für gepaarte Stichproben  \\

\pythoninline{st.ttest_ind(series1, series2, equal_var=False)} \\
Statistischer Test für ungepaarte Stichproben  \\

\pythoninline{st.mannwhitneyu(series1, series2)} \\
Mann-Whitney U-Test (aka Wilcoxon Rank-sum Test) \\

\pythoninline{st.ttest_1samp(series, 1).pvalue} \\
P-Wert eines T-Tests für eine Series berechnen \\
mit der Nullhypothese $u=1$ \\
\textbf{!} \textit{pvalue} ist der P-Wert des zweiseitigen Tests

\subsection*{Varianzanalyse}
\pythoninline{from statsmodels.graphics.factorplots} \\
\pythoninline{	import interaction_plot} \\
\pythoninline{from statsmodels.stats.anova import anova_lm} \\
\pythoninline{from statsmodels.formula.api import ols} \\
\pythoninline{from patsy.contrasts import Sum} \\
Benötigte Bibliotheksfunktionen für Varianzanalysen

\columnbreak

\pythoninline{sns.stripplot(x="...", y="...", data=frame)} \\
Varianz-Analyse mit Stripcharts zwischen \textit{x} und \textit{y} \\

\pythoninline{sns.boxplot(x="...", y="...", data=frame)} \\
Varianz-Analyse mit Boxplots zwischen \textit{x} und \textit{y} \\

\pythoninline{sns.distplot(Fstat, kde=False, norm_hist=True, 
	hist_kws=dict(edgecolor="black", linewidth=2))} \\
F-Statistik plotten \\

\pythoninline{sns.boxplot(series.index.weekday, series)} \\
\pythoninline{sns.boxplot(series.index.month, series)} \\
\pythoninline{sns.boxplot(series.index.quarter, series)} \\
\pythoninline{sns.boxplot(series.index.year, series)} \\
Boxplot für gruppierte Daten nach Wochentag, Monat, \\
Quartal, Jahr, ... anzeigen \\
\textbf{!} \textit{series} muss ein DatetimeIndex haben  \\

\begin{tcolorbox}
\begin{python}
frame = pd.DataFrame({
  "Treatment": np.repeat(["Vak","CO2"], 3),
  "steak_id":[7.66, 6.98, 7.80, 5.26, ...]
})
\end{python}
\end{tcolorbox}
 
\pythoninline{fit = ols("steak_id~Treatment", data=frame).fit()} \\
\pythoninline{fit.summary()} \\
Gruppenmittelmodell berechnen zwischen der Id des \\ 
Steaks und der ausgeführten Behandlung \\

\pythoninline{fit_pred = fit.get_prediction()} \\
\pythoninline{fit_pred.conf_int()} \\
Vertrauensintervalle für Gruppenmittelwerte \\

\pythoninline{anova_lm(fit)} \\
Anova Tabelle berechnen

\columnbreak

\begin{tcolorbox}
\begin{python}
frame = pd.DataFrame({
  "Batch": np.tile(["1", "2", "3"], 4),
  "Methode": np.repeat(["8500", "9100"], 6),
  "Y": np.array([90.3, 89.2, 98.2, ...])
})
\end{python}
\end{tcolorbox}

\pythoninline{interaction_plot(x=frame["Batch"], }\\
\pythoninline{	trace=frame["Methode"], response=frame["Y"])} \\
Interaktionsplot erstellen \\
- entlang der y-Achse die Zielgrösse (response) \\
- entlang der x-Achse der durch x festgelegte Faktor \\
- für jede Stufe in trace wird dann eine Linie gezogen \\

\pythoninline{formula = "Y ~ C(Methode, Sum) + C(Batch, Sum)"} \\
\pythoninline{fit = ols(formula, data=frame).fit()} \\
Zweiweg-Varianzanalyse mit Blöcken zwischen den \\
Datenspalten \textit{Methode} und \textit{Batch} \\

\begin{tcolorbox}
\begin{python}
frame = pd.DataFrame({
  "Konz": np.repeat(["A", "B", "C","D"], 6),
  "Temp": np.tile(np.repeat(["1", "2"],3),4),
  "Y": np.array([82, 46, 16, 20, 13, ...])
})
\end{python}
\end{tcolorbox}

\pythoninline{formula = "Y ~ C(Konz, Sum) * C(Temp, Sum)"} \\
\pythoninline{fit = ols(formula, data=frame).fit()} \\
Faktorielle Experimente mit den zwei \\
Faktoren \textit{Konzentration} und \textit{Temperatur}

\subsection*{Zeitreihen}
\pythoninline{from statsmodels.tsa.seasonal } \\
\pythoninline{	import seasonal_decompose} \\
Benötigte Bibliotheksfunktionen für Zeitreihen \\

\pythoninline{def boxcox(x, lambd):} \\
\pythoninline{	return np.log(x) if (lambd == 0) \} \\
\pythoninline{		else (x**lambd - 1) / lambd} \\
BoxCox-Funktion definieren \\

\begin{tcolorbox}
\begin{verbatim}
TravelDate  Passengers
0   1/1/1949         112
1   2/1/1949         118
2   3/1/1949         132
3   4/1/1949         129
4   5/1/1949         121
.   ........         ...
\end{verbatim}
\end{tcolorbox}

\pythoninline{series = frame["Passengers"].shift(-5)} \\
Zeitverschiebung (shifting) mit $k = -5$ \\

\pythoninline{col = frame["TravelDate"]} \\
\pythoninline{frame["TravelDate"] = pd.DatetimeIndex(col)} \\
\pythoninline{frame.set_index("TravelDate", inplace=True)} \\
Datums-Index einer Zeitreihe setzen \\

\pythoninline{frame["Passengers"].rolling(window=12).mean()} \\
Bewegendes Mittel (moving average) berechnen \\
bei einer Fenstergrösse von 12 \\

\pythoninline{seasonal_decompose(frame["Passengers"], } \\
\pythoninline{	model="additive", freq=12).plot()} \\
Zerlegen einer Zeitreihe in die verschiedenen Faktoren \\
bei einer Fenstergrösse von 12 \\

\pythoninline{seasonal_decompose(np.log(frame["Passengers"]),} \\ 
\pythoninline{	model="add").resid.plot()} \\
Residuen Plot von logarithmierten Daten anzeigen \\

\pythoninline{seasonal_decompose(frame["Passengers"], } \\ 
\pythoninline{	model="mul").plot()} \\
Zerlegen einer Zeitreihe mit dem multiplikativen Modell \\

\pythoninline{frame.resample("A").mean()} \\
Zeitreihe so umformen, dass jede Zeile den \\
Jahresdurchschnitt eines Jahres enthält

\columnbreak

\subsection*{Allgemein}
\pythoninline{from scipy.special import comb} \\
\pythoninline{comb(N=5, k=3, exact=True)} \\
Binomialkoeffizient berechnen, in diesem Beispiel $\binom{5}{3}$ \\

\pythoninline{import warnings} \\
\pythoninline{warnings.filterwarnings('ignore')} \\
Python-Warnungen ausblenden \\

\pythoninline{import matplotlib} \\
\pythoninline{matplotlib.rcParams['figure.dpi'] = 150} \\
Plot grösser machen (für High-DPI-Screens) \\

\pythoninline{%matplotlib inline} \\
Plots in Jupyter-Notebook direkt anzeigen

\end{multicols*}
\end{document}

